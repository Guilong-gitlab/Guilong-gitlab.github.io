[{"content":"high_level 代码解读 这段代码主要用于控制Unitree G1机器人的动作，包括机械臂的控制和通过DDS（数据分发服务）进行数据通信。\n包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import time import sys # DDS通信相关 from unitree_sdk2py.core.channel import ChannelPublisher, ChannelSubscriber, ChannelFactoryInitialize # DDS消息类型 (LowCmd 和 LowState) # - unitree_hg_msg_dds__LowCmd_ 是低级控制命令的数据结构 # - unitree_hg_msg_dds__LowState_ 是低级状态反馈的数据 from unitree_sdk2py.idl.default import unitree_hg_msg_dds__LowCmd_ from unitree_sdk2py.idl.default import unitree_hg_msg_dds__LowState_ from unitree_sdk2py.idl.unitree_hg.msg.dds_ import LowCmd_ from unitree_sdk2py.idl.unitree_hg.msg.dds_ import LowState_ # CRC 校验工具类 # CRC（Cyclic Redundancy Check，循环冗余校验） # 用来对发给机器人或者从机器人收到的数据做校验 # 就像给快递贴封条，防止数据在传输途中出错或被篡改 from unitree_sdk2py.utils.crc import CRC # 定时循环线程工具 # RecurrentThread 能让你定义一个线程 # 并且每隔一定时间（比如 20 毫秒）自动执行一次某个函数 # 用来做实时控制，不会卡住主线程 from unitree_sdk2py.utils.thread import RecurrentThread # 控制运动模式切换的客户端 # MotionSwitcherClient 能让你切换机器人的动作模式（比如运动模式、静止模式） from unitree_sdk2py.comm.motion_switcher.motion_switcher_client import MotionSwitcherClient # 数值计算 import numpy as np G1JointIndex类 该类已经介绍过了，不再赘述，详细可跳转：\nCustom 类 其实该类同样在底层example中出现过，但不是顶层与底层的代码有细节上的差异，所以在下面再介绍一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__(self): self.time_ = 0.0 # 当前时间 self.control_dt_ = 0.02 # 控制周期，表示每次更新控制命令的时间间隔，单位：秒 self.duration_ = 3.0 # 每个动作的持续时间，单位：秒 self.counter_ = 0 # 动作执行计数器，用于控制动作的执行次数 self.weight = 0. # 重量，可能用于计算力或加速度等 self.weight_rate = 0.2 # 重量变化的速率系数 self.kp = 60. # 比例增益，PID 控制中的比例部分 self.kd = 1.5 # 微分增益，PID 控制中的微分部分 self.dq = 0. # 关节的角速度（假设这里用于某些计算） self.tau_ff = 0. # 偏置力矩（用于补偿） self.mode_machine_ = 0 # 控制模式的状态机标志 # 控制命令对象，用于发送低级控制指令给机器人 self.low_cmd = unitree_hg_msg_dds__LowCmd_() self.low_state = None # 机器人当前的状态反馈 self.first_update_low_state = False # 标记是否首次更新低级状态 self.crc = CRC() # CRC 校验工具，确保数据的完整性 self.done = False # 标记动作是否完成 # 目标位置，机器人动作的目标位置 self.target_pos = [ 0., kPi_2, 0., kPi_2, 0., 0., 0., 0., -kPi_2, 0., kPi_2, 0., 0., 0., 0, 0, 0 ] # 定义要控制的机械臂关节索引 self.arm_joints = [ G1JointIndex.LeftShoulderPitch, G1JointIndex.LeftShoulderRoll, G1JointIndex.LeftShoulderYaw, G1JointIndex.LeftElbow, G1JointIndex.LeftWristRoll, G1JointIndex.LeftWristPitch, G1JointIndex.LeftWristYaw, G1JointIndex.RightShoulderPitch, G1JointIndex.RightShoulderRoll, G1JointIndex.RightShoulderYaw, G1JointIndex.RightElbow, G1JointIndex.RightWristRoll, G1JointIndex.RightWristPitch, G1JointIndex.RightWristYaw, G1JointIndex.WaistYaw, G1JointIndex.WaistRoll, G1JointIndex.WaistPitch ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def Init(self): # 创建发布者，负责发送控制命令给机器人 # \u0026#34;rt/arm_sdk\u0026#34; 是通道名称，LowCmd_ 是要发布的数据类型 self.arm_sdk_publisher = ChannelPublisher(\u0026#34;rt/arm_sdk\u0026#34;, LowCmd_) self.arm_sdk_publisher.Init() # 初始化发布者 # 创建订阅者，负责接收机器人的低级状态反馈 # \u0026#34;rt/lowstate\u0026#34; 是订阅的通道名称，LowState_ 是接收的数据类型 self.lowstate_subscriber = ChannelSubscriber(\u0026#34;rt/lowstate\u0026#34;, LowState_) self.lowstate_subscriber.Init(self.LowStateHandler, 10) # 初始化订阅者，并设置回调函数 LowStateHandler def Start(self): # 创建一个定时执行的线程，每隔 control_dt_ 秒调用一次 LowCmdWrite 方法 self.lowCmdWriteThreadPtr = RecurrentThread( interval=self.control_dt_, # 设置间隔时间 target=self.LowCmdWrite, # 设置目标方法 name=\u0026#34;control\u0026#34; # 线程名称 ) # 等待直到首次更新低级状态数据 while self.first_update_low_state == False: time.sleep(1) # 当低级状态数据首次更新完成后，启动控制命令写入线程 if self.first_update_low_state == True: self.lowCmdWriteThreadPtr.Start() def LowStateHandler(self, msg: LowState_): # 处理收到的低级状态数据，并保存 self.low_state = msg # 标记首次更新低级状态完成 if self.first_update_low_state == False: self.first_update_low_state = True 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def LowCmdWrite(self): self.time_ += self.control_dt_ # 更新时间 if self.time_ \u0026lt; self.duration_ : # [Stage 1]: 将机器人设置为零姿态 self.low_cmd.motor_cmd[G1JointIndex.kNotUsedJoint].q = 1 # 1:启用 arm_sdk, 0:禁用 arm_sdk for i, joint in enumerate(self.arm_joints): # 计算当前时间与动作持续时间的比例，用于平滑过渡 ratio = np.clip(self.time_ / self.duration_, 0.0, 1.0) # 设置控制命令 self.low_cmd.motor_cmd[joint].tau = 0. # 设置扭矩为 0 self.low_cmd.motor_cmd[joint].q = (1.0 - ratio) * self.low_state.motor_state[joint].q # 根据比例更新目标位置 self.low_cmd.motor_cmd[joint].dq = 0. # 设置角速度为 0 self.low_cmd.motor_cmd[joint].kp = self.kp # 设置比例增益 self.low_cmd.motor_cmd[joint].kd = self.kd # 设置微分增益 elif self.time_ \u0026lt; self.duration_ * 3 : # [Stage 2]: 抬起机械臂 for i, joint in enumerate(self.arm_joints): # 计算动作的比例，用于从零姿态过渡到目标姿态 ratio = np.clip((self.time_ - self.duration_) / (self.duration_ * 2), 0.0, 1.0) # 设置控制命令 self.low_cmd.motor_cmd[joint].tau = 0. # 设置扭矩为 0 self.low_cmd.motor_cmd[joint].q = ratio * self.target_pos[i] + (1.0 - ratio) * self.low_state.motor_state[joint].q # 目标姿态 self.low_cmd.motor_cmd[joint].dq = 0. # 设置角速度为 0 self.low_cmd.motor_cmd[joint].kp = self.kp # 设置比例增益 self.low_cmd.motor_cmd[joint].kd = self.kd # 设置微分增益 elif self.time_ \u0026lt; self.duration_ * 6 : # [Stage 3]: 将机器人恢复到零姿态 for i, joint in enumerate(self.arm_joints): # 计算从抬起动作过渡回零姿态的比例 ratio = np.clip((self.time_ - self.duration_ * 3) / (self.duration_ * 3), 0.0, 1.0) # 设置控制命令 self.low_cmd.motor_cmd[joint].tau = 0. # 设置扭矩为 0 self.low_cmd.motor_cmd[joint].q = (1.0 - ratio) * self.low_state.motor_state[joint].q # 恢复到原始位置 self.low_cmd.motor_cmd[joint].dq = 0. # 设置角速度为 0 self.low_cmd.motor_cmd[joint].kp = self.kp # 设置比例增益 self.low_cmd.motor_cmd[joint].kd = self.kd # 设置微分增益 elif self.time_ \u0026lt; self.duration_ * 7 : # [Stage 4]: 释放 arm_sdk for i, joint in enumerate(self.arm_joints): # 计算比例，逐步禁用 arm_sdk ratio = np.clip((self.time_ - self.duration_ * 6) / (self.duration_), 0.0, 1.0) self.low_cmd.motor_cmd[G1JointIndex.kNotUsedJoint].q = (1 - ratio) # 1:启用 arm_sdk, 0:禁用 arm_sdk else: # 所有阶段完成，设置 done 为 True，表示任务完成 self.done = True # 进行 CRC 校验，确保控制命令数据完整性 self.low_cmd.crc = self.crc.Crc(self.low_cmd) # 将控制命令写入到发布者 self.arm_sdk_publisher.Write(self.low_cmd) main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 print(\u0026#34;WARNING: Please ensure there are no obstacles around the robot while running this example.\u0026#34;) input(\u0026#34;Press Enter to continue...\u0026#34;) # 如果运行脚本时带参数，则使用参数指定的网络接口 # 否则用默认自动探测网卡 if len(sys.argv) \u0026gt; 1: ChannelFactoryInitialize(0, sys.argv[1]) else: ChannelFactoryInitialize(0) # 创建控制对象 custom = Custom() custom.Init() custom.Start() # 主循环，每秒检查一次是否动作执行完成 while True: time.sleep(1) if custom.done: print(\u0026#34;Done!\u0026#34;) sys.exit(-1) ","date":"2025-07-09T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%87%E6%A0%91%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90python-sdk%E5%BC%80%E5%8F%91g1%E9%A1%B6%E5%B1%82%E6%A1%88%E4%BE%8B/","title":"宇树开源代码解析：Python-SDK开发G1顶层案例"},{"content":"high_level 代码解读 这个脚本演示了如何使用Unitree SDK控制机器人臂的动作。它通过终端提供一个用户界面，允许用户选择不同的预定义动作来控制机器人的臂部。用户可以输入动作的名称或ID，机器人将执行相应的臂部动作。可执行的动作包括“握手”、“击掌”、“拥抱”、“鼓掌”、“心形手势”、“亲吻”等，每个动作对应一个特定的臂部动作。\n主要功能概述： TestOption：脚本通过TestOption类定义了不同的机器人臂动作，每个动作都有一个name（名称）和id（编号）。 用户界面：终端界面允许用户输入动作的名称或ID。如果输入有效，机器人将执行对应的动作。 机器人动作执行：一旦选择了有效的动作，脚本通过G1ArmActionClient与机器人臂进行通信，执行相应的动作。 持续循环：脚本在循环中运行，允许用户不断输入不同的动作命令，并让机器人执行相应的动作。 引入pyhton包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 导入time模块，用于处理时间相关的操作 import time # 导入sys模块，用于处理与Python解释器相关的参数 import sys # 从unitree_sdk2py库中导入ChannelSubscriber和ChannelFactoryInitialize类 # ChannelSubscriber用于订阅通信通道，ChannelFactoryInitialize用于初始化通信通道 from unitree_sdk2py.core.channel import ChannelSubscriber, ChannelFactoryInitialize # 导入G1ArmActionClient类，用于控制机器人臂部动作 from unitree_sdk2py.g1.arm.g1_arm_action_client import G1ArmActionClient # 导入action_map字典，包含机器人臂部动作名称与对应操作的映射关系 from unitree_sdk2py.g1.arm.g1_arm_action_client import action_map # 导入dataclass装饰器，用于简化数据类的创建 from dataclasses import dataclass 类的定义 TestOption 1 2 3 4 5 # 使用dataclass装饰器定义一个数据类TestOption，包含两个字段：name（动作名称）和id（动作ID） @dataclass class TestOption: name: str # 动作名称 id: int # 动作ID 这里提一下 @dataclass 这个装饰器，他的作用是简化类的定义，当一些类的定义比较简单的时候就不需要进行复杂的初始化等python语言的撰写，其写法等价于\n1 2 3 4 5 6 7 8 9 10 class TestOption: def __init__(self, name, id): self.name = name self.id = id def __repr__(self): return f\u0026#34;TestOption(name={self.name}, id={self.id})\u0026#34; def __eq__(self, other): return self.name == other.name and self.id == other.id 接着我们定义都有哪些可以选择的动作以及其对应的id号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 创建一个包含不同动作选项的列表，每个选项是一个TestOption实例 option_list = [ TestOption(name=\u0026#34;release arm\u0026#34;, id=0), # 释放手臂 TestOption(name=\u0026#34;shake hand\u0026#34;, id=1), # 握手 TestOption(name=\u0026#34;high five\u0026#34;, id=2), # 击掌 TestOption(name=\u0026#34;hug\u0026#34;, id=3), # 拥抱 TestOption(name=\u0026#34;high wave\u0026#34;, id=4), # 高举手 TestOption(name=\u0026#34;clap\u0026#34;, id=5), # 鼓掌 TestOption(name=\u0026#34;face wave\u0026#34;, id=6), # 面部挥手 TestOption(name=\u0026#34;left kiss\u0026#34;, id=7), # 左侧亲吻 TestOption(name=\u0026#34;heart\u0026#34;, id=8), # 心形手势 TestOption(name=\u0026#34;right heart\u0026#34;, id=9), # 右侧心形手势 TestOption(name=\u0026#34;hands up\u0026#34;, id=10), # 举手 TestOption(name=\u0026#34;x-ray\u0026#34;, id=11), # X光动作 TestOption(name=\u0026#34;right hand up\u0026#34;, id=12), # 右手举起 TestOption(name=\u0026#34;reject\u0026#34;, id=13), # 拒绝动作 TestOption(name=\u0026#34;right kiss\u0026#34;, id=14), # 右侧亲吻 TestOption(name=\u0026#34;two-hand kiss\u0026#34;, id=15), # 双手亲吻 ] UserInterface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # 定义用户交互界面类 class UserInterface: # 初始化方法 def __init__(self): self.test_option_ = None # 初始化时没有选择的测试选项 # 将输入的字符串转换为整数，如果无法转换，则返回 None def convert_to_int(self, input_str): try: return int(input_str) # 尝试将字符串转换为整数 except ValueError: # 如果转换失败（值错误），返回 None return None # 终端交互方法 def terminal_handle(self): input_str = input(\u0026#34;Enter id or name: \\n\u0026#34;) # 提示用户输入动作的 ID 或名称 # 如果用户输入 \u0026#34;list\u0026#34;，则列出所有的测试选项 if input_str == \u0026#34;list\u0026#34;: self.test_option_.name = None # 重置选择的动作名称 self.test_option_.id = None # 重置选择的动作ID # 列出所有选项 for option in option_list: print(f\u0026#34;{option.name}, id: {option.id}\u0026#34;) return # 检查用户输入的名称或 ID 是否与某个选项匹配 for option in option_list: # 如果输入的是动作名称，或者输入的是动作 ID if input_str == option.name or self.convert_to_int(input_str) == option.id: # 找到匹配的选项后，更新 test_option_ self.test_option_.name = option.name self.test_option_.id = option.id # 显示选中的测试选项 print(f\u0026#34;Test: {self.test_option_.name}, test_id: {self.test_option_.id}\u0026#34;) return # 如果没有找到匹配的选项 print(\u0026#34;No matching test option found.\u0026#34;) main文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 如果命令行参数数量小于 2，说明用户没有输入网络接口参数 if len(sys.argv) \u0026lt; 2: # 提示用户正确的脚本使用方法 print(f\u0026#34;Usage: python3 {sys.argv[0]} networkInterface\u0026#34;) # 程序以错误码 -1 退出 sys.exit(-1) # 提醒用户，在运行这个示例之前，确保机器人周围没有障碍物，避免发生碰撞 print(\u0026#34;WARNING: Please ensure there are no obstacles around the robot while running this example.\u0026#34;) # 等待用户按下回车键再继续执行，给用户一个准备时间 input(\u0026#34;Press Enter to continue...\u0026#34;) # 使用用户输入的网络接口名初始化通信通道 # sys.argv[1] 就是命令行传入的网络接口，比如 \u0026#34;eth0\u0026#34; ChannelFactoryInitialize(0, sys.argv[1]) # 创建一个 TestOption 实例，用于存储当前选中的动作（初始为空） test_option = TestOption(name=None, id=None) # 创建用户交互界面对象 user_interface = UserInterface() # 将 test_option 对象赋值给用户交互界面，用于在交互过程中记录用户的选择 user_interface.test_option_ = test_option # 创建 G1ArmActionClient 对象，用于与机器人手臂通信和控制动作 armAction_client = G1ArmActionClient() # 设置超时时间为 10 秒，避免操作长时间无响应 armAction_client.SetTimeout(10.0) # 初始化 armAction_client，建立与机器人手臂的通信 armAction_client.Init() # （以下两行被注释掉）可以用来获取并打印机器人手臂支持的所有动作列表 # actionList = armAction_client.GetActionList() # print(\u0026#34;actionList\\n\u0026#34;,actionList) 后面就是根据输入选择具体执行的代码了，这个就不用每一行都解释了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 # 提示用户，可以输入 \u0026#34;list\u0026#34; 命令来查看所有支持的动作 print(\u0026#34;Input \\\u0026#34;list\\\u0026#34; to list all test option ...\u0026#34;) while True: user_interface.terminal_handle() print(f\u0026#34;Updated Test Option: Name = {test_option.name}, ID = {test_option.id}\u0026#34;) if test_option.id == 0: armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 1: armAction_client.ExecuteAction(action_map.get(\u0026#34;shake hand\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 2: armAction_client.ExecuteAction(action_map.get(\u0026#34;high five\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 3: armAction_client.ExecuteAction(action_map.get(\u0026#34;hug\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 4: armAction_client.ExecuteAction(action_map.get(\u0026#34;high wave\u0026#34;)) elif test_option.id == 5: armAction_client.ExecuteAction(action_map.get(\u0026#34;clap\u0026#34;)) elif test_option.id == 6: armAction_client.ExecuteAction(action_map.get(\u0026#34;face wave\u0026#34;)) elif test_option.id == 7: armAction_client.ExecuteAction(action_map.get(\u0026#34;left kiss\u0026#34;)) elif test_option.id == 8: armAction_client.ExecuteAction(action_map.get(\u0026#34;heart\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 9: armAction_client.ExecuteAction(action_map.get(\u0026#34;right heart\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 10: armAction_client.ExecuteAction(action_map.get(\u0026#34;hands up\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 11: armAction_client.ExecuteAction(action_map.get(\u0026#34;x-ray\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 12: armAction_client.ExecuteAction(action_map.get(\u0026#34;right hand up\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 13: armAction_client.ExecuteAction(action_map.get(\u0026#34;reject\u0026#34;)) time.sleep(2) armAction_client.ExecuteAction(action_map.get(\u0026#34;release arm\u0026#34;)) elif test_option.id == 14: armAction_client.ExecuteAction(action_map.get(\u0026#34;right kiss\u0026#34;)) elif test_option.id == 15: armAction_client.ExecuteAction(action_map.get(\u0026#34;two-hand kiss\u0026#34;)) time.sleep(1) graph TD A[程序开始] --\u003e B{参数数量 \u003e= 2?} B -- 否 --\u003e C[打印用法提示 Usage...] C --\u003e D[退出程序 sys.exit(-1)] B -- 是 --\u003e E[打印警告: 确保周围无障碍] E --\u003e F[等待用户按回车继续] F --\u003e G[初始化通道 ChannelFactoryInitialize] G --\u003e H[创建 TestOption 对象] H --\u003e I[创建 UserInterface 对象] I --\u003e J[将 test_option 分配给 UserInterface] J --\u003e K[创建 G1ArmActionClient 客户端] K --\u003e L[设置超时 10 秒] L --\u003e M[初始化 armAction_client] M --\u003e N[提示用户可输入 list 查看所有动作] ","date":"2025-07-08T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%87%E6%A0%91%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90python-sdk%E5%BC%80%E5%8F%91g1%E9%A1%B6%E5%B1%82%E6%A1%88%E4%BE%8B/","title":"宇树开源代码解析：Python-SDK开发G1顶层案例"},{"content":"high_level 代码解读 这段脚本通过 unitree_sdk2py 库控制Unitree G1机器人，主要实现了音量控制、语音合成、运动和LED灯光控制。它首先通过网络接口初始化与机器人系统的通信，然后测试了音量调节、语音播放、挥手动作和LED颜色变化等功能，整个过程通过一定的延时控制各操作顺序。\n引入包 1 2 3 4 5 6 7 8 9 10 11 12 import time # 导入time库，用于控制程序的延时操作 import sys # 导入sys库，用于处理命令行参数 # 从unitree_sdk2py.core.channel模块导入ChannelSubscriber和ChannelFactoryInitialize # ChannelSubscriber用于订阅频道，ChannelFactoryInitialize用于初始化通信通道 from unitree_sdk2py.core.channel import ChannelSubscriber, ChannelFactoryInitialize # 从unitree_sdk2py.g1.audio.g1_audio_client模块导入AudioClient，用于控制机器人的音频功能 from unitree_sdk2py.g1.audio.g1_audio_client import AudioClient # 从unitree_sdk2py.g1.loco.g1_loco_client模块导入LocoClient，用于控制机器人的运动功能 from unitree_sdk2py.g1.loco.g1_loco_client import LocoClient 主函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 if len(sys.argv) \u0026lt; 2: # 检查命令行参数是否少于2个（即没有提供网络接口参数） print(f\u0026#34;Usage: python3 {sys.argv[0]} networkInterface\u0026#34;) # 如果参数不足，打印使用说明 sys.exit(-1) # 退出程序，返回错误码-1 # 使用提供的网络接口参数初始化与机器人系统的通信 ChannelFactoryInitialize(0, sys.argv[1]) # 创建音频客户端对象，用于控制机器人的音频功能 audio_client = AudioClient() audio_client.SetTimeout(10.0) # 设置音频客户端的超时时间为10秒 audio_client.Init() # 初始化音频客户端 # 创建运动客户端对象，用于控制机器人的运动功能 sport_client = LocoClient() sport_client.SetTimeout(10.0) # 设置运动客户端的超时时间为10秒 sport_client.Init() # 初始化运动客户端 # 获取当前音量并打印 ret = audio_client.GetVolume() print(\u0026#34;debug GetVolume: \u0026#34;, ret) # 设置音量为85 audio_client.SetVolume(85) # 再次获取音量并打印，验证音量设置是否成功 ret = audio_client.GetVolume() print(\u0026#34;debug GetVolume: \u0026#34;, ret) # 使机器人执行挥手动作 sport_client.WaveHand() # 使用TTS（语音合成）功能播放语音，机器人说出自定义消息 audio_client.TtsMaker(\u0026#34;大家好!我是宇树科技人形机器人。语音开发测试例程运行成功！ 很高兴认识你！\u0026#34;, 0) time.sleep(8) # 等待8秒钟 # 播放下一条语音，告知进行灯带测试 audio_client.TtsMaker(\u0026#34;接下来测试灯带开发例程！\u0026#34;, 0) time.sleep(1) # 等待1秒钟 # 控制LED灯带颜色为红色 audio_client.LedControl(255, 0, 0) time.sleep(1) # 等待1秒钟 # 控制LED灯带颜色为绿色 audio_client.LedControl(0, 255, 0) time.sleep(1) # 等待1秒钟 # 控制LED灯带颜色为蓝色 audio_client.LedControl(0, 0, 255) # 等待3秒钟 time.sleep(3) # 播放语音结束语，告知测试完毕 audio_client.TtsMaker(\u0026#34;测试完毕，谢谢大家！\u0026#34;, 0) graph LR A[开始] --\u003e B{检查网络接口参数} B --\u003e|无参数| C[显示使用说明并退出] B --\u003e|有参数| D[初始化通信通道] D --\u003e E[创建音频客户端] E --\u003e F[设置音频客户端超时并初始化] F --\u003e G[获取当前音量] G --\u003e H[设置音量为85] H --\u003e I[验证音量设置] I --\u003e J[创建运动客户端] J --\u003e K[设置运动客户端超时并初始化] K --\u003e L[执行挥手动作] L --\u003e M[执行语音合成：欢迎语] M --\u003e N[执行语音合成：灯带测试] N --\u003e O[控制LED颜色：红] O --\u003e P[控制LED颜色：绿] P --\u003e Q[控制LED颜色：蓝] Q --\u003e R[执行语音合成：测试完毕] R --\u003e S[结束] ","date":"2025-07-04T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%87%E6%A0%91%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90python-sdk%E5%BC%80%E5%8F%91g1%E6%A1%88%E4%BE%8B/","title":"宇树开源代码解析：Python-SDK开发G1案例"},{"content":"low_level 代码解读 g1_low_level_example 是底层的测试例子，这个例子也很简单，下面只有3个类，分别是\nG1JointIndex Mode Custom 核心模块部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 硬件通信层 from unitree_sdk2py.core.channel import ChannelPublisher, ChannelFactoryInitialize from unitree_sdk2py.core.channel import ChannelSubscriber, ChannelFactoryInitialize # 数据结构定义 from unitree_sdk2py.idl.default import unitree_hg_msg_dds__LowCmd_ from unitree_sdk2py.idl.default import unitree_hg_msg_dds__LowState_ # 控制算法部分 class Custom: def __init__(self): # 初始化控制参数 def Init(self): # 建立通信连接 def Start(self): # 启动控制线程 def LowStateHandler(self, msg): # 状态回调处理 def LowCmdWrite(self): # 核心控制逻辑 逐步解析 Unitree SDK核心通信组件 1 2 3 4 5 6 # 发布者（用于发送控制指令） from unitree_sdk2py.core.channel import ChannelPublisher # 订阅者（用于接收状态反馈） from unitree_sdk2py.core.channel import ChannelSubscriber # 通信初始化（配置DDS网络） from unitree_sdk2py.core.channel import ChannelFactoryInitialize 机器人数据结构定义 1 2 3 4 5 6 7 8 # DDS通信协议下的底层命令数据结构 from unitree_sdk2py.idl.default import unitree_hg_msg_dds__LowCmd_ # DDS通信协议下的底层状态数据结构 from unitree_sdk2py.idl.default import unitree_hg_msg_dds__LowState_ # 优化后的命令结构（实际使用版本） from unitree_sdk2py.idl.unitree_hg.msg.dds_ import LowCmd_ # 优化后的状态结构（实际使用版本） from unitree_sdk2py.idl.unitree_hg.msg.dds_ import LowState_ 工具类组件 1 2 3 4 5 6 # 数据校验模块 from unitree_sdk2py.utils.crc import CRC # 定时循环线程 from unitree_sdk2py.utils.thread import RecurrentThread # 运动模式切换客户端（用于安全控制） from unitree_sdk2py.comm.motion_switcher.motion_switcher_client import MotionSwitcherClient 机器人参数定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 G1_NUM_MOTOR = 29 # G1型号机器人电机总数（注意这是三腰的G1） # 比例增益系数（控制响应速度） Kp = [ 60, 60, 60, 100, 40, 40, # 腿部关节（髋/膝/踝） 60, 60, 60, 100, 40, 40, # 另一侧腿部 60, 40, 40, # 腰部关节 40, 40, 40, 40, 40, 40, 40, # 左臂关节 40, 40, 40, 40, 40, 40, 40 # 右臂关节 ] # 微分增益系数（抑制振荡） Kd = [ 1, 1, 1, 2, 1, 1, # 腿部（膝关节需要更强的阻尼） 1, 1, 1, 2, 1, 1, # 另一侧腿部 1, 1, 1, # 腰部 1, 1, 1, 1, 1, 1, 1, # 左臂 1, 1, 1, 1, 1, 1, 1 # 右臂 ] G1JointIndex类 G1JointIndex类的功能是为Unitree G1机器人的29个电机关节提供统一的索引编号，同时其支持两种控制模式（PR模式/AB模式）的别名映射\n腿部关节定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 LeftHipPitch = 0 # 左髋关节俯仰轴（前后摆动） LeftHipRoll = 1 # 左髋关节横滚轴（左右摆动） LeftHipYaw = 2 # 左髋关节偏航轴（旋转） LeftKnee = 3 # 左膝关节（仅俯仰） LeftAnklePitch = 4 # 左踝关节俯仰（PR模式名） LeftAnkleB = 4 # 左踝关节B轴（AB模式名，与Pitch同物理关节） LeftAnkleRoll = 5 # 左踝关节横滚（PR模式名） LeftAnkleA = 5 # 左踝关节A轴（AB模式名，与Roll同物理关节） RightHipPitch = 6 # 右髋关节俯仰轴 RightHipRoll = 7 # 右髋关节横滚轴 RightHipYaw = 8 # 右髋关节偏航轴 RightKnee = 9 # 右膝关节 RightAnklePitch = 10 # 右踝关节俯仰 RightAnkleB = 10 # 右踝B轴（AB模式） RightAnkleRoll = 11 # 右踝关节横滚 RightAnkleA = 11 # 右踝A轴（AB模式） 腰部关节定义（注意G1机器人腰部仅Yaw轴有效，其余轴被机械锁定，如要解锁需重新标定）\n1 2 3 4 5 WaistYaw = 12 # 腰部旋转关节（有效） WaistRoll = 13 # 腰部横滚（G1实际锁定无效） WaistA = 13 # 同Roll轴的AB模式别名（无效） WaistPitch = 14 # 腰部俯仰（G1实际锁定无效） WaistB = 14 # 同Pitch轴的AB模式别名（无效） 手部关节定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 LeftShoulderPitch = 15 # 左肩俯仰 LeftShoulderRoll = 16 # 左肩横滚 LeftShoulderYaw = 17 # 左肩偏航 LeftElbow = 18 # 左肘关节 LeftWristRoll = 19 # 左腕横滚（有效） LeftWristPitch = 20 # 左腕俯仰（23自由度版本无效） LeftWristYaw = 21 # 左腕偏航（23自由度版本无效） RightShoulderPitch = 22 # 右肩俯仰 RightShoulderRoll = 23 # 右肩横滚 RightShoulderYaw = 24 # 右肩偏航 RightElbow = 25 # 右肘关节 RightWristRoll = 26 # 右腕横滚（有效） RightWristPitch = 27 # 右腕俯仰（23自由度版本无效） RightWristYaw = 28 # 右腕偏航（23自由度版本无效） Mode 1 2 3 class Mode: PR = 0 # 独立控制俯仰(Pitch)和横滚(Roll)关节，精确轨迹跟踪（如足端画圆） AB = 1 # 协同控制A/B关节（将两个关节运动耦合），快速步态生成（如奔跑、跳跃） Custom类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def __init__(self): # 时间控制参数 self.time_ = 0.0 # 累计控制时间（单位：秒） self.control_dt_ = 0.002 # 控制周期（2ms）与Unitree G1控制器的 500Hz刷新率 严格对应 self.duration_ = 3.0 # 单阶段持续时间（3秒） # 在LowCmdWrite()中的阶段划分： # if self.time_ \u0026lt; self.duration_: # 阶段1：零位归位 # elif self.time_ \u0026lt; self.duration_ * 2: # 阶段2：PR模式摆动 # else: # 阶段3：AB模式摆动 # 状态监控变量 self.counter_ = 0 # 循环计数器（用于非实时任务） self.update_mode_machine_ = False # 模式切换标志位 # 机器人控制接口 self.low_cmd = unitree_hg_msg_dds__LowCmd_() # 底层命令容器 self.low_state = None # 状态反馈缓存（初始为空） # 控制模式配置 self.mode_pr_ = Mode.PR # 默认PR模式（独立控制） self.mode_machine_ = 0 # 整机状态机模式 # 循环冗余校验实例 self.crc = CRC() # 在发送指令前计算校验码 # self.low_cmd.crc = self.crc.Crc(self.low_cmd) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def Init(self): # 运动模式客户端初始化 self.msc = MotionSwitcherClient() # 创建模式切换客户端 self.msc.SetTimeout(5.0) # 设置5秒超时（防止阻塞） self.msc.Init() # 建立与底层控制器的连接 #模式状态检查与释放 status, result = self.msc.CheckMode() # 检查当前控制模式 while result[\u0026#39;name\u0026#39;]: # 如果已有控制者（name非空） self.msc.ReleaseMode() # 释放当前控制权 status, result = self.msc.CheckMode() # 重新检查 time.sleep(1) # 避免高频请求 # DDS通信初始化 # 命令发布者配置 # self.lowcmd_publisher_ = ChannelPublisher(\u0026#34;rt/lowcmd\u0026#34;, LowCmd_) # rt/lowcmd 为硬件定义的实时控制通道 self.lowcmd_publisher_.Init() # 状态订阅者配置 # self.lowstate_subscriber = ChannelSubscriber(\u0026#34;rt/lowstate\u0026#34;, LowState_) self.lowstate_subscriber.Init(self.LowStateHandler, 10) 关于模式状态检查与释放的内容跟可由以下图进行解释，当其他程序异常退出未释放控制权时，此循环可强制回收控制\ngraph LR A[开始] --\u003e B{CheckMode} B --\u003e|有控制者| C[ReleaseMode] C --\u003e B B --\u003e|无控制者| D[继续初始化] 1 2 3 4 5 6 7 8 9 10 # 物理层布局 # +-------------------+ +-------------------+ # | Control PC | | Robot Controller| # | | | | # | Publisher |\u0026lt;-----\u0026gt;| Motor Drivers | # | (rt/lowcmd) | DDS | | # | | | | # | Subscriber |\u0026lt;-----\u0026gt;| State Sensors | # | (rt/lowstate) | | | # +-------------------+ +-------------------+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def Start(self): # 创建周期性控制线程 self.lowCmdWriteThreadPtr = RecurrentThread( interval=self.control_dt_, # 控制周期(2ms) target=self.LowCmdWrite, # 目标控制函数 name=\u0026#34;control\u0026#34; # 线程名称，独立的控制线程确保实时性，避免被主线程其他任务阻塞 ) # 等待状态机更新 while self.update_mode_machine_ == False: time.sleep(1) # 当前实现缺少超时机制，可能导致永久等待，新增 timeout = 10 # 10秒超时 start_time = time.time() while not self.update_mode_machine_ and (time.time() - start_time \u0026lt; timeout): time.sleep(0.1) if not self.update_mode_machine_: raise RuntimeError(\u0026#34;状态反馈超时\u0026#34;) # 启动控制线程，仅在确认收到状态反馈后启动控制，Start()方法激活周期性控制 if self.update_mode_machine_ == True: self.lowCmdWriteThreadPtr.Start() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # DDS状态消息回调函数（异步触发），当机器人控制器通过rt/lowstate通道发送新状态时自动调用 def LowStateHandler(self, msg: LowState_): self.low_state = msg # 拷贝最新状态 if self.update_mode_machine_ == False: self.mode_machine_ = self.low_state.mode_machine self.update_mode_machine_ = True # 标志位置位 # 值\t机器人模式\t允许控制类型 # 0\t待机\t仅允许空指令 # 1\t力控模式\t力矩指令有效 # 2\t位置控制模式\t位置/速度指令有效 self.counter_ +=1 if (self.counter_ % 500 == 0) : # 每500次回调（约1秒） self.counter_ = 0 # print(self.low_state.imu_state.rpy) # 打印姿态角(roll/pitch/yaw) # 添加时间戳和格式化 rpy = np.degrees(self.low_state.imu_state.rpy) # 弧度转角度 print(f\u0026#34;[{time.ctime()}] RPY: {rpy[0]:.2f}° {rpy[1]:.2f}° {rpy[2]:.2f}°\u0026#34;) sequenceDiagram 机器人控制器-\u003e\u003e+控制程序: 发送LowState_(500Hz) 控制程序-\u003e\u003e+安全系统: 检查mode_machine 安全系统--\u003e\u003e-控制程序: 允许/拒绝控制 控制程序-\u003e\u003e+执行器: 计算下一周期指令 执行器-\u003e\u003e-机器人控制器: 发送LowCmd_ 下面的内容就是该底层example要测试的东西，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def LowCmdWrite(self): self.time_ += self.control_dt_ # 累计控制时间(2ms步长) if self.time_ \u0026lt; self.duration_ : # 阶段1：零位归零 for i in range(G1_NUM_MOTOR): ratio = np.clip(self.time_ / self.duration_, 0.0, 1.0) self.low_cmd.mode_pr = Mode.PR self.low_cmd.mode_machine = self.mode_machine_ self.low_cmd.motor_cmd[i].mode = 1 # 1:Enable, 0:Disable self.low_cmd.motor_cmd[i].tau = 0. self.low_cmd.motor_cmd[i].q = (1.0 - ratio) * self.low_state.motor_state[i].q self.low_cmd.motor_cmd[i].dq = 0. self.low_cmd.motor_cmd[i].kp = Kp[i] self.low_cmd.motor_cmd[i].kd = Kd[i] elif self.time_ \u0026lt; self.duration_ * 2 : # 阶段2：PR模式摆动 max_P = np.pi * 30.0 / 180.0 max_R = np.pi * 10.0 / 180.0 t = self.time_ - self.duration_ L_P_des = max_P * np.sin(2.0 * np.pi * t) # 左踝俯仰 L_R_des = max_R * np.sin(2.0 * np.pi * t) # 右踝横滚 R_P_des = max_P * np.sin(2.0 * np.pi * t) R_R_des = -max_R * np.sin(2.0 * np.pi * t) self.low_cmd.mode_pr = Mode.PR self.low_cmd.mode_machine = self.mode_machine_ self.low_cmd.motor_cmd[G1JointIndex.LeftAnklePitch].q = L_P_des self.low_cmd.motor_cmd[G1JointIndex.LeftAnkleRoll].q = L_R_des self.low_cmd.motor_cmd[G1JointIndex.RightAnklePitch].q = R_P_des self.low_cmd.motor_cmd[G1JointIndex.RightAnkleRoll].q = R_R_des else : # 阶段3：AB模式摆动 max_A = np.pi * 30.0 / 180.0 max_B = np.pi * 10.0 / 180.0 t = self.time_ - self.duration_ * 2 L_A_des = max_A * np.sin(2.0 * np.pi * t) # 左踝A轴 L_B_des = max_B * np.sin(2.0 * np.pi * t + np.pi) # 左踝B轴(反相) R_A_des = -max_A * np.sin(2.0 * np.pi * t) R_B_des = -max_B * np.sin(2.0 * np.pi * t + np.pi) self.low_cmd.mode_pr = Mode.AB self.low_cmd.mode_machine = self.mode_machine_ self.low_cmd.motor_cmd[G1JointIndex.LeftAnkleA].q = L_A_des self.low_cmd.motor_cmd[G1JointIndex.LeftAnkleB].q = L_B_des self.low_cmd.motor_cmd[G1JointIndex.RightAnkleA].q = R_A_des self.low_cmd.motor_cmd[G1JointIndex.RightAnkleB].q = R_B_des max_WristYaw = np.pi * 30.0 / 180.0 L_WristYaw_des = max_WristYaw * np.sin(2.0 * np.pi * t) R_WristYaw_des = max_WristYaw * np.sin(2.0 * np.pi * t) self.low_cmd.motor_cmd[G1JointIndex.LeftWristRoll].q = L_WristYaw_des self.low_cmd.motor_cmd[G1JointIndex.RightWristRoll].q = R_WristYaw_des self.low_cmd.crc = self.crc.Crc(self.low_cmd) # 计算校验码 self.lowcmd_publisher_.Write(self.low_cmd) # 发送指令 将上述代码可以总结为如下的流程图\ngraph TD A[开始] --\u003e B{time_ \u003c duration_?} B --\u003e|是| C[阶段1:零位归零] B --\u003e|否| D{time_\u003c2*duration_?} D --\u003e|是| E[阶段2:PR模式摆动] D --\u003e|否| F[阶段3:AB模式摆动] C --\u003e G[发送指令] E --\u003e G F --\u003e G G --\u003e H[等待下一个周期] 主运行文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;WARNING: Please ensure there are no obstacles around the robot while running this example.\u0026#34;) input(\u0026#34;Press Enter to continue...\u0026#34;) if len(sys.argv)\u0026gt;1: ChannelFactoryInitialize(0, sys.argv[1]) # 使用自定义配置 else: ChannelFactoryInitialize(0) # 使用默认配置 # custom = Custom() # 创建控制器实例 # custom.Init() # 初始化通信连接 # custom.Start() # 启动控制线程 # while True: # time.sleep(1) try: with Custom() as custom: # 实现上下文管理器 custom.Init() custom.Start() while True: time.sleep(1) except KeyboardInterrupt: print(\u0026#34;安全停止中...\u0026#34;) graph LR A[创建Custom对象] --\u003e B[Init初始化] B --\u003e C[Start启动线程] C --\u003e D[运行主循环] D --\u003e|异常| E[自动调用析构] ","date":"2025-07-04T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%87%E6%A0%91%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90python-sdk%E5%BC%80%E5%8F%91g1%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/","title":"宇树开源代码解析：Python-SDK开发G1底层逻辑"},{"content":"high_level 代码解读 ","date":"2025-07-04T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%87%E6%A0%91%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90python-sdk%E5%BC%80%E5%8F%91g1%E9%A1%B6%E5%B1%82%E6%A1%88%E4%BE%8B/","title":"宇树开源代码解析：Python-SDK开发G1顶层案例"},{"content":"GO2程序内容解读 low_level 代码解读 high-level 代码解读 front_camera 代码解读 ","date":"2025-07-04T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%87%E6%A0%91%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90python-sdk%E5%BC%80%E5%8F%91go2/","title":"宇树开源代码解析：Python-SDK开发Go2"},{"content":"部分开源代码的文件介绍 注：宇树科技产品种类很多，本文作者主要关注内容为GO2和G1两个系列的机器人代码\nunitree_guide-main：宇树科技出版的书籍《四足机器人控制算法\u0026ndash;建模、控制与实践》的配套开源控制算法工程。通过该程序包，可以学习机器人关节电机控制方法，同时也可以学习简单的足式机器人力控算法。该工程包含了仿真与实际两种开发环境，并且可通过命令实现二者之间的切换。\nunitree_IL_lerobot-main:宇树开源的基于LeRobot的机器人巨神智能/模仿学习框架，支持模仿学习算法（如DT、ACT等），适配宇树人形机器人G1、机械臂Z1和灵巧手Dex3等硬件。本人只关注G1相关内容。\nunitree_mujoco-main:基于宇树SDK2和mujuco开发的模拟器。使用者可以通过unitree_sdk2、unitree_ros2和unitree_sdk2_python开发的程序集成到这个模拟器环境当中。\nunitree_rl_gym-main:宇树强化学习实现的仓库，支持Go2、H1、H1_2 和 G1。这是作者本人关注的重点内容，本人想要从事的研究就是利用强化学习对G1进行二次开发。\nunitree_ros2-master:ROS2环境下开发Go2、B2的机器人功能包（接口与unitree_sdk2保持一致）。\nunitree_ros-master:用于宇树机器人的ROS仿真包，包含宇树所有机器人的urdf文件，可通过该包中获取宇树机器人的质量、惯量、力矩等信息。\nunitree_sdk2_python-master:SDK2的python接口，用于开发Go2、B2、H1和G1机器人。这是作者本人关注的重点之一，上面说了本人想要在G1上运行强化学习算法，但底层必须掌握SDK开发才能继续学习。\nunitree_sdk2-main:用于开发Go2、B2和H1机器人的SDK包，(功能与unitree_legged_sdk功能类似，只是适配的机器人不同)。\nUnitreecameraSDK-main: GO1机器人相机SDK例程。（本人想要研究Go2、尤其是G1的相机，但是宇树目前没有开源G1的相机的例程，所以对Go1的先参考一下，掌握后研究G1的相机。。）\n下面就让我们一个一个进入机器人的内部进行解析。\nunitree_sdk2_python 官方使用文档（个人修订版） 安装 官方提示依赖库 python\u0026gt;=3.8 cyclonedds==0.10.2 numpy opencv-python 个人安装python版本 python == 3.8 安装 unitree_sdk2_python 在终端中执行：\n1 2 3 4 5 cd ~ sudo apt install python3-pip git clone https://github.com/unitreerobotics/unitree_sdk2_python.git cd unitree_sdk2_python pip3 install -e . FAQ 1. pip3 install -e . 遇到报错 Could not locate cyclonedds. Try to set CYCLONEDDS_HOME or CMAKE_PREFIX_PATH\n该错误提示找不到 cyclonedds 路径。首先编译安装cyclonedds：\n1 2 3 4 5 cd ~ git clone https://github.com/eclipse-cyclonedds/cyclonedds -b releases/0.10.x cd cyclonedds \u0026amp;\u0026amp; mkdir build install \u0026amp;\u0026amp; cd build cmake .. -DCMAKE_INSTALL_PREFIX=../install cmake --build . --target install 进入 unitree_sdk2_python 目录，设置 CYCLONEDDS_HOME 为刚刚编译好的 cyclonedds 所在路径，再安装 unitree_sdk2_python\n1 2 3 cd ~/unitree_sdk2_python export CYCLONEDDS_HOME=\u0026#34;~/cyclonedds/install\u0026#34; pip3 install -e . 详细见： https://pypi.org/project/cyclonedds/#installing-with-pre-built-binaries\n使用 python sdk2 接口与 unitree_skd2的接口保持一致，通过请求响应或订阅发布topic实现机器人的状态获取和控制。相应的例程位于/example目录下。在运行例程前，需要根据文档 https://support.unitree.com/home/zh/developer/Quick_start 配置好机器人的网络连接。\nDDS通讯 在终端中执行：\n1 python3 ./example/helloworld/publisher.py 打开新的终端，执行：\n1 python3 ./example/helloworld/subscriber.py 可以看到终端输出的数据信息。publisher.py 和 subscriber.py 传输的数据定义在 user_data.py 中，用户可以根据需要自行定义需要传输的数据结构。\n高层状态和控制 高层接口的数据结构和控制方式与unitree_sdk2一致。具体可见：https://support.unitree.com/home/zh/developer/sports_services\n高层状态 终端中执行：\n1 python3 ./example/high_level/read_highstate.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。\n高层控制 终端中执行：\n1 python3 ./example/high_level/sportmode_test.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。 该例程提供了几种测试方法，可根据测试需要选择:\n1 2 3 4 5 # test.StandUpDown() # 站立趴下 # test.VelocityMove() # 速度控制 # test.BalanceAttitude() # 姿态控制 # test.TrajectoryFollow() # 轨迹跟踪 # test.SpecialMotions() # 特殊动作 底层状态和控制 底层接口的数据结构和控制方式与unitree_sdk2一致。具体可见：https://support.unitree.com/home/zh/developer/Basic_services\n底层状态 终端中执行：\n1 python3 ./example/low_level/lowlevel_control.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。程序会输出右前腿hip关节的状态、IMU和电池电压信息。\n底层电机控制 首先使用 app 关闭高层运动服务(sport_mode)，否则会导致指令冲突。 终端中执行：\n1 python3 ./example/low_level/lowlevel_control.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。左后腿 hip 关节会保持在0角度 (安全起见，这里设置 kp=10, kd=1)，左后腿 calf 关节将持续输出 1Nm 的转矩。\n遥控器状态获取 终端中执行：\n1 python3 ./example/wireless_controller/wireless_controller.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。 终端将输出每一个按键的状态。对于遥控器按键的定义和数据结构可见： https://support.unitree.com/home/zh/developer/Get_remote_control_status\n前置摄像头 使用opencv获取前置摄像头(确保在有图形界面的系统下运行, 按 ESC 退出程序):\n1 python3 ./example/front_camera/camera_opencv.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。\n避障开关 1 python3 ./example/obstacles_avoid_switch/obstacles_avoid_switch.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。机器人将循环开启和关闭避障功能。关于避障服务，详细见 https://support.unitree.com/home/zh/developer/ObstaclesAvoidClient\n灯光音量控制 1 python3 ./example/vui_client/vui_client_example.py enp2s0 其中 enp2s0 为机器人所连接的网卡名称，请根据实际情况修改。机器人将循环调节音量和灯光亮度。该接口详细见 https://support.unitree.com/home/zh/developer/VuiClient\n文件内容解读 像readme这样的文件本文不再赘述，该开源代码下有两个文件夹（）和一个python程序。\n首先文件目录下的setup.py文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # 从setuptools模块导入必要的函数, setup: 用于配置和创建Python包的主函数，find_packages: 自动发现目录中Python包的辅助函数 from setuptools import setup, find_packages # 调用setup函数定义包配置 setup( # 必需参数: 包名称（用于pip安装） name=\u0026#39;unitree_sdk2py\u0026#39;, # 必需参数: 包版本号（遵循语义化版本规范） version=\u0026#39;1.0.1\u0026#39;, # 必需参数: 包含在分发包中的Python包列表，find_packages()自动发现包，\u0026#39;include\u0026#39;参数限制只包含指定的包名 packages=find_packages(include=[\u0026#39;unitree_sdk2py\u0026#39;,\u0026#39;unitree_sdk2py.*\u0026#39;]), # 可选参数: 作者名称（个人或组织） author=\u0026#39;UnitreeRobotics\u0026#39;, # 可选参数: 作者联系邮箱 author_email=\u0026#39;unitree@unitree.com\u0026#39;, # 可选参数: 从README.md读取的长描述，这将显示在PyPI上 long_description=open(\u0026#39;README.md\u0026#39;).read(), # 可选参数: 指定长描述的格式（本例为markdown） long_description_content_type=\u0026#34;text/markdown\u0026#34;, # 可选参数: 软件许可证标识（本例为BSD 3-Clause）\u0026#39; license=\u0026#34;BSD-3-Clause\u0026#34;, # 可选参数: 包的简短描述 description=\u0026#39;Unitree robot sdk version 2 for python\u0026#39;, # 可选参数: 项目相关URL（通常是源代码、文档等） project_urls={ \u0026#34;Source Code\u0026#34;: \u0026#34;https://github.com/unitreerobotics/unitree_sdk2_python\u0026#34;, }, # 可选参数: 指定Python版本要求（\u0026gt;=3.8） python_requires=\u0026#39;\u0026gt;=3.8\u0026#39;, install_requires=[ \u0026#34;cyclonedds==0.10.2\u0026#34;, # 指定DDS版本 \u0026#34;numpy\u0026#34;, \u0026#34;opencv-python\u0026#34;, ], ) 不难看出setup.py就是python的pip安装包，索引指向文件夹下的unitree_sdk2py。所以很明显，unitree_sdk2py是包内程序，所以unitree_sdk2py这个文件夹下的内容就不展开分析，重点在于example中的例子。\nexample文件夹下有很多例子，我们重点关注以下Go2和G1，此外，obstacles_avoid 很明显是避障程序，那个这个程序是否适配不同版本的机器人？\n个人认为是不适配的，因为自己测试下来，默认的人形机器人是没有避障的。那就要继续思考两个问题。\nGo2是能实现避障的，他的避障是依靠单纯依靠雷达还是单纯依靠视觉，还是二者结合？ G1理论上是有摄像头的，这个如何调用本身就是个问题，其次如果依靠视觉进行避障的话，在G1上能不能实现避障功能？ ","date":"2025-07-04T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%87%E6%A0%91%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%900%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E6%A1%A3%E4%BB%8B%E7%BB%8D/","title":"宇树开源代码解析0：文件及文档介绍"},{"content":"VSCode 配置 XeLaTeX + Biber 编译环境教程 本教程介绍如何在 VSCode 中配置 XeLaTeX 编译 LaTeX 文档，并使用 biber 管理参考文献，适用于需要中文支持、引用文献的论文写作环境。\n1. 安装环境 1.1 安装 TeX Live 访问官网 https://tug.org/texlive/ 下载并安装 TeX Live（推荐完整版，包含全部宏包）。\n1.2 安装 VSCode 插件 打开 VSCode，前往扩展商店，安装插件：LaTeX Workshop\n2. 配置 VSCode settings.json 打开 VSCode 设置（Ctrl + Shift + P → Preferences: Open Settings (JSON)）， （注意，根据个人需要决定是Open WorkSpace Settings (JSON) 还是Open Users Settings (JSON)，前者只针对当前文件夹下的工程，后者是针对全局设置的） 将以下内容复制粘贴进去：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \u0026#34;latex-workshop.latex.tools\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOC%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;biber\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;biber\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;%DOCFILE%\u0026#34;] } ], \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xelatex -\u0026gt; biber -\u0026gt; xelatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [\u0026#34;xelatex\u0026#34;, \u0026#34;biber\u0026#34;, \u0026#34;xelatex\u0026#34;, \u0026#34;xelatex\u0026#34;] } ], \u0026#34;latex-workshop.latex.recipe.default\u0026#34;: \u0026#34;xelatex -\u0026gt; biber -\u0026gt; xelatex*2\u0026#34;, \u0026#34;latex-workshop.view.pdf.viewer\u0026#34;: \u0026#34;tab\u0026#34;, \u0026#34;latex-workshop.latex.clean.enabled\u0026#34;: true, \u0026#34;latex-workshop.synctex.afterBuild.enabled\u0026#34;: true, \u0026#34;latex-workshop.chktex.enabled\u0026#34;: false, \u0026#34;latex-workshop.latex.rootFile.useMagic\u0026#34;: true } 如果你有现成的文件，就可以直接使用你自己的文件去进行测试是否配置完成，如果你没有现成的文件，想重新创建一个文件，可以用下面的代码试试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 % !TEX program = xelatex \\documentclass[12pt]{article} \\usepackage[UTF8]{ctex} \\usepackage{amsmath, amssymb} \\usepackage[backend=biber, style=numeric]{biblatex} \\addbibresource{ref.bib} \\title{XeLaTeX 测试文档} \\author{测试作者} \\date{\\today} \\begin{document} \\maketitle 这是一个测试文档，用于演示 XeLaTeX 和 biber 的配置。\\cite{khasminskii2011stochastic} \\printbibliography \\end{document} 1 2 3 4 5 6 7 8 @book{khasminskii2011stochastic, title={Stochastic stability of differential equations}, author={Khasminskii, Rafail}, year={2011}, publisher={Springer}, volume={66} } 3. 添加快捷键删除中间文件 由于latex编译会有很多中文文件产生，vscode可以自己添加快捷键删除自己想要删除的文件，只需要\n（Ctrl + Shift + P → Preferences: Open Keyboard Shortcuts (JSON)）\n然后输入\n1 2 3 4 5 6 7 8 9 10 [ { \u0026#34;key\u0026#34;: \u0026#34;ctrl+shift+delete\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;workbench.action.terminal.sendSequence\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;cd \u0026#39;${fileDirname}\u0026#39;\\u000DGet-ChildItem -Recurse -Include *.aux,*.bbl,*.bcf,*.blg,*.log,*.out,*.toc,*.lof,*.lot,*.fls,*.fdb_latexmk,*.run.xml | Remove-Item -Force -ErrorAction SilentlyContinue\\u000D\u0026#34; } } ] // 这是我个人设置，设置完成后只需要按住ctrl+shift+delete即可快速删除所有中间文件，但是有个中间文件synctex.gz这个文件如果你不需要，就在上面的“text”中添加对应的文件后缀名，我选择不删除这个，引文这个是pdf和latex文字跳转的对应文件，这个文件不删除，随时都可以通过pdf跳转对应的位置 注意上面这个其实是在Powershell里面运行了一个命令，所以重点在于你的运行终端最好是powershell，所以建议将终端切换到powershell，步骤如下： （实测如果是cmd有时候好使，有时候不好使）\n打开命令面板（Ctrl + Shift + P） 输入并选择： 1 Terminal: Select Default Profile 选择： 1 PowerShell 注意快捷键只能向“当前终端”发指令。\n","date":"2025-04-10T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/vscode%E9%85%8D%E7%BD%AExelatex/","title":"VsCode配置XeLatex"},{"content":"由于我们在电脑的日常使用以及更换电脑等诸多问题上，不可避免的一定要做的事情就是要重装系统，因此本博客的目的是记录下我现有电脑中的全部软件及安装方法，以方便未来更换电脑或者重装系统时不会因为缺失某些文件而导致无法正常工作。\n博客中的所有软件均为作者本人常用的软件及设置，有兴趣的可以保存以后自己装电脑的时候避免遗忘。\n重装windows系统 更改桌面文件存储路径 这一步其实算作必备操作，但是由于后续安装软件会导入大量的桌面快捷方式，建议先把这一步做了。\n必备软件 微信 谷歌浏览器 Adobe PDF阅读器 bandizip压缩软件 火绒安全 matlab zotero clash mathtype Texlive + Texstudio 向日葵远程控制或ToDesk 网易邮箱大师、网易有道翻译 PYcharm 和 Anaconda Vscode utorrent Office 全家桶 WPS 腾讯会议 其他系列网盘 百度网盘 中国移动云盘 阿里云盘 夸克网盘 EV录屏 GIt + GO 必备设置 右键选项添加通过VSCode打开文件或文件夹 Anaconda 添加常用环境 更改微信文件存储位置（要不C盘迟早有一天要炸） Github 配置电脑适配 VSCode 添加Copilot IE浏览器和Google 浏览器登录账号，同步账号内的所有内容 ","date":"2025-03-10T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87%E6%89%80%E6%9C%89%E8%BD%AF%E4%BB%B6/","title":"装机必备所有软件"},{"content":"配置Hugo 1. 安装必要软件 按照以下顺序安装软件（因为相互依赖关系）：\nGit\nPowershell 7.x\nWin11 自带 Powershell 的版本是 5.1，需要更新到 7.x。首先，在 win11 自带 Powershell 里输入以下指令，安装最新稳定版：\n1 winget install --id Microsoft.Powershell --source winget 接下来的命令行操作都在 7.x 的 Powershell 内执行。\nVS Code\nGo\nGo 安装说明见官网: Go 安装指南\nGithub 账户\nchoco\n参考官网 choco 安装指南 安装 choco，执行以下指令：\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) Hugo\n执行以下指令，利用 choco 安装 Hugo：\n1 choco install hugo-extended Dart Sass\n执行以下指令，利用 choco 安装 Sass：\n1 choco install sass 2. 利用 hugo 先在本地端搭建网页 在 Powershell 切换至文件夹 A，执行以下指令：\n1 2 # 通过 hugo 简历一个新的项目文件，主文件的格式采用yaml hugo new site demo --format yaml 执行完上面指令后，Hugo 会生成网站，网站根目录为 ./demo。\n注意：打开网站根目录 A/demo，会发现 Hugo 生成了很多文件，其中最重要的是配置文件 hugo.yaml。网站的配置文件，会略有区别。常见的配置文件有：\nhugo.yaml / hugo.toml config.yaml / config.toml 切换路径至网站根目录 A/demo，执行 git 初始化，为后续步骤做准备。\n1 git init 3. Hugo 配置 Theme 首先安装 Hugo 主题，所有的主题可以前往 Hugo themes 的官网进行下载 hugo themes 官网， 后面的所有才做都在 stack 主题下的介绍。 所有的主题都可使用，你可以选择自己喜欢的格式进行使用，本人选择 stack 主题的原因是该主题的作者提供了一个非常详细的使用文档，可前往下面的链接查看：stack 主题作者的详细说明文档。\n安装 Hugo 主题 papermod，执行以下指令：\n1 2 3 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # 当我们要从 github 上拉取仓库时需要这个指令 git submodule update --remote --merge 执行上述指令后，主题 papermod 会存放在路径 A/demo/themes/papermod。\n配置主题 papermod 的配置文件 hugo.yaml 如下：\n1 echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 执行完上面指令后，网站配置文件最后一行会添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 baseURL: https://yylustb.github.io/ languageCode: en-us title: My New Hugo Site theme: [\u0026#34;PaperMod\u0026#34;] paginate: 5 # 列表页显示文章数 # 默认支持首页 HTML 页面、RSS 订阅、JSON（搜索），可以满足大多数 Hugo 博客需求。 outputs: home: # 主页输出 - HTML - RSS - JSON markup: goldmark: # Hugo 默认使用的 Markdown 渲染引擎 renderer: unsafe: true # 控制是否允许在 Markdown 中渲染 “不安全（raw）” 的 HTML 标签 highlight: lineNos: true # 是否在代码高亮时显示行号 noClasses: false # 不要禁用 class codeFences: true # 启用 Markdown 代码块语法（```） style: \u0026#34;monokai\u0026#34; params: env: production title: ExampleSite # 站点的标题 description: \u0026#34;ExampleSite description\u0026#34; # 站点的描述信息 keywords: [Blog, Portfolio, PaperMod] # 站点的关键词，有助于 SEO author: Me # 站点的作者 images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] # 用于社交分享时的默认封面图片 DateFormat: \u0026#34;January 2, 2006\u0026#34; # 文章日期的显示格式 defaultTheme: auto # dark, light # 站点默认主题模式（自动适应用户偏好） disableThemeToggle: false # 是否禁用深色/浅色模式切换 ShowReadingTime: true # 显示阅读时间 ShowShareButtons: true # 显示社交分享按钮 ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false menu: # 定义导航菜单 main: # Hugo 主题 PaperMod 默认的主菜单（可以有多个菜单） - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 4. 添加网页内容 在路径 A/demo 下，执行以下指令：\n1 hugo new content posts/hello.md 执行完上面指令后，Hugo 会生成网页，保存路径为 A/demo/content/posts/hello.md。打开该文档，会看到以下内容：\n1 2 3 4 5 +++ date = \u0026#39;2025-02-11T07:14:09+08:00\u0026#39; draft = false title = \u0026#39;My First Post\u0026#39; +++ 5. Hugo 本地部署 如果 draft = true，执行以下指令（以下两个指令是一样的，只执行一个即可）：\n1 2 hugo server -D hugo server --buildDrafts 如果 draft = false，执行：\n1 hugo server 最后，可以在浏览器输入地址 http://localhost:1313/，即看到网页内容。\n6. Hugo 部署到 Github Pages 🚀 有个特别奇葩的bug，就是在当你的github.io建立好了之后你想打开看看是否生效的时候，换个浏览器，不要用IE，IE浏览器由于存在大量缓存，导致他一直产生的是缓存的数据，让我以为一直没弄好，卡在这会纯浪费很长时间。 6.1 新建 Github 仓库 step 1. 新建 Github 仓库，仓库名必须为 username.github.io，username 为 Github 用户名。\nstep 2. 将本地仓库推到 Github 仓库\n切换路径至 A/demo，执行以下指令：\n1 2 3 4 5 git remote add origin \u0026#34;Github 仓库 SSH 地址\u0026#34; # 不需要井号 git add . git commit -m \u0026#34;First Submit\u0026#34; git branch -M main git push -u origin main 刷新 Github 仓库，会看到 git 仓库已上传。\nstep 3. 这时 username.github.io 还是不能访问，接下来进行部署。\nstep 3.1 建立部署配置文件 回到本地仓库根目录，建立文件夹 .github/workflows，在该文件夹下新建文件 hugo.yaml。hugo.yaml的内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 name: Deploy Hugo site to Pages on: push: branches: - main workflow_dispatch: permissions: contents: read pages: write id-token: write concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false defaults: run: shell: bash jobs: build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.141.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Build with Hugo run: hugo --gc --minify --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 通过 Hugo 和 Github 实现网页的生成 下面提供了两种不同的方法来实现网页搭建，方法1是将你的全部源文件公开，方法2你可以完全不公开自己的底层文件，依旧能生成网站，需要公开的只有hugo搭建页面时自动生成的文件。选择哪种方案取决于你自己的需求，如果想不公开自己的底层文件，可直接跳转到方法2. step 3.2 选择 GitHub 部署方式 Github 项目页面 -\u0026gt; Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Source -\u0026gt; 改为 GitHub Actions。\nstep 3.3 查看 GitHub 部署结果 Github 项目页面 -\u0026gt; Action 页面会看到 GitHub 的部署情况。部署正确后即可看到 username.github.io 页面。\n1 2 这是一个详细的 Hugo 网站搭建及部署流程，涵盖了从环境配置到最终部署的每个步骤。 ","date":"2025-02-26T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/hugo-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1hugo--github-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/","title":"Hugo 搭建网站系列教程1：Hugo + Github 的配置方法"},{"content":"Hugo Markdown 格式介绍 在使用 Hugo 构建静态网站时，Markdown 文件是最常用的内容格式。本文将介绍如何在 Hugo 中使用 Markdown 格式，并涵盖常见的排版技巧和功能。\n目录 标题 段落和换行 列表 链接和图片 强调和粗体 代码块 引用 表格 自定义内容 标题 Markdown 使用 # 符号来定义标题，支持从一级标题到六级标题：\n1 2 3 4 5 6 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 这会渲染成：\n一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 段落和换行 段落之间通过空行来分隔，换行可以使用两个空格加回车：\n1 2 3 4 这是第一段内容。 这是第二段内容，后面紧跟着换行 这是新的一行。 列表 无序列表 无序列表使用星号 * 或者减号 - 来表示：\n1 2 3 4 - 项目一 - 项目二 - 子项目 1 - 子项目 2 有序列表 有序列表使用数字和句点来表示：\n1 2 3 1. 第一项 2. 第二项 3. 第三项 链接和图片 链接 创建链接的语法为 [链接文本](链接地址)：\n1 [GitHub](https://github.com) 图片 图片的语法与链接相似，但前面有一个感叹号 !：\n1 ![Hugo logo](https://gohugo.io/images/hugo-logo-wide.svg) 强调和粗体 强调 使用单个星号 * 或下划线 _ 来表示斜体（强调）：\n1 2 *斜体文本* _斜体文本_ 粗体 使用双星号 ** 或双下划线 __ 来表示粗体：\n1 2 **粗体文本** __粗体文本__ 同时使用强调和粗体 1 ***加粗和斜体*** 代码块 行内代码 行内代码使用反引号 ` 包围：\n1 这是 `代码` 示例。 块级代码 块级代码缩进四个空格：\n1 2 这是一个块级代码 也可以通过缩进来表示 引用 引用文本使用 \u0026gt; 符号：\n1 2 \u0026gt; 这是一个引用块。 \u0026gt; 你可以用它来引用他人的话。 表格 Markdown 支持简单的表格，使用管道符号 | 和减号 - 来构建：\n1 2 3 4 5 | 姓名 | 年龄 | 职业 | |--------|------|----------| | 张三 | 25 | 工程师 | | 李四 | 30 | 设计师 | | 王五 | 28 | 产品经理 | 这会渲染成：\n姓名 年龄 职业 张三 25 工程师 李四 30 设计师 王五 28 产品经理 ","date":"2025-02-26T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/hugo-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2markdown-%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D/","title":"Hugo 搭建网站系列教程2：Markdown 格式介绍"},{"content":"","date":"2025-02-26T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/hugo-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B3hugo--github-%E6%90%AD%E5%BB%BA%E7%BD%91%E9%A1%B5%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Hugo 搭建网站系列教程3：Hugo + Github 搭建网页时遇到的问题"},{"content":"下面是一份从零开始的完整示例，教你如何在 Hugo 中通过 MathJax 实现公式的自动编号和引用。之所以不用 KaTeX，是因为 KaTeX 默认没有“自动给所有行间公式编号”的功能；若要自动编号并且想用 \\label、\\ref 来引用，MathJax 更合适。\n以下操作基于你已经装好 Hugo 并且在使用常见主题（比如我使用的就是 hugo-theme-stack）进行网站构建为前提。\n第 1 步：禁用或移除主题自带的 KaTeX 大多数 Hugo 主题（例如 hugo-theme-stack）会在检测到 params.article.math = true 或在文章 Front Matter 里写了 math: true 时自动加载 KaTeX。为了让我们接下来放置的 MathJax 生效，需要先禁用这个自动加载。\n如果你之前在 config.yaml（或 config.toml 等）里写了：\n1 2 3 params: article: math: true # 默认启用 KaTeX 请改成 false 或者干脆去掉这一行。例如：\n1 2 3 params: article: math: false 或者删除这行，这样主题就不会再自动插入 KaTeX 相关脚本。\n如果你的主题没有任何 KaTeX 配置，可直接略过本步。\n第 2 步：创建一个自定义的部分模板，放入 MathJax 脚本 假设你想让 MathJax 在每个页面全局生效，你可以在 Hugo 站点根目录下（不是主题目录）的 layouts/partials/ 文件夹里新建一个文件，如 mathjax-support.html，其内容类似下面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script\u0026gt; window.MathJax = { tex: { tags: \u0026#39;ams\u0026#39;, // 启用自动编号 (AMS 环境) inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;,\u0026#39;\\\\]\u0026#39;]], packages: [\u0026#39;base\u0026#39;, \u0026#39;ams\u0026#39;] // 允许使用 \\label{eq1} / \\ref{eq1} / \\eqref{eq1} 来引用公式 }, options: { // 可根据需求，决定是否让 MathJax 遇到报错时仍然渲染其他部分 // 或是否启用 menuOptions: {...} } }; \u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; tags: \u0026lsquo;ams\u0026rsquo; 让所有用 \\begin{equation}...\\end{equation} 包裹的块级公式自动产生连续编号。 默认行内公式仍使用 $...$，块级公式使用 $$...$$。如果你想强制都用 \\(...\\) 和 \\[...\\]，只要修改 inlineMath 与 displayMath 里分隔符即可。 第 3 步：在 \u0026lt;head\u0026gt; 中引入这个部分模板 你需要把 mathjax-support.html 放到网页 \u0026lt;head\u0026gt; 里，让浏览器加载它。以 hugo-theme-stack 为例，你可以这样做：\n在站点根目录下（或主题支持的 override 目录）找到/创建 layouts/partials/head.html。 在你希望插入 MathJax 的地方，添加： 1 {{ partial \u0026#34;mathjax-support.html\u0026#34; . }} 大多数主题在 head.html 里会有一些公共的 \u0026lt;meta\u0026gt;、CSS 引用等内容，你只需要在适当的地方插入上面那行 partial 即可，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Lang }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; ... {{ partial \u0026#34;mathjax-support.html\u0026#34; . }} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这样，每次渲染页面时，都会自动注入我们第 2 步写的 MathJax 配置和脚本。\n第 4 步：编写带编号和引用的公式 完成以上三步后，你就可以在 Hugo 的 Markdown 文件中写出 LaTeX 环境来获得自动编号。通常推荐用 equation 环境，并配合 \\label / \\ref / \\eqref 等。\n4.1 自动编号 示例一：一个简单的自动编号方程\n1 2 3 \\begin{equation} E = mc^2 \\end{equation} 编译后会自动给这行方程打上一个编号，比如 “(1)”。后面写的会自动递增编号。\n4.2 手动引用 如果想在文章中其他地方引用这个公式，可以给它加个 \\label 标记：\n1 2 3 4 \\begin{equation} E = mc^2 \\label{eq:energy} \\end{equation} 然后在文字里写：\n1 我们可以看到公式 (\\ref{eq:energy}) 给出了质量和能量之间的关系。 MathJax 会把 (\\ref{eq:energy}) 渲染成对应公式编号，比如 “(1)”，并且会在公式处加相应的内部跳转（如果主题或浏览器支持的话）。\n也可以用 \\eqref{eq:energy} 的方式引用，它会直接带上括号并形成链接。\n补充：如何修改 文件 找到 layouts/partials/head/head.html\n进入你的 Hugo 项目目录： 1 themes/hugo-theme-stack/layouts/partials/head/ 找到 head.html 文件。 复制到你的站点目录\n复制 themes/hugo-theme-stack/layouts/partials/head/head.html 到 Hugo 站点根目录下的 layouts/partials/head/ 目录： 1 2 mkdir -p layouts/partials/head cp themes/hugo-theme-stack/layouts/partials/head/head.html layouts/partials/head/head.html 编辑 layouts/partials/head/head.html\n打开 layouts/partials/head/head.html，在 \u0026lt;/head\u0026gt; 之前插入： 1 {{ partial \u0026#34;mathjax-support.html\u0026#34; . }} 示例修改后的 head.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34; dir=\u0026#34;{{ default `ltr` .Language.LanguageDirection }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; {{ partial \u0026#34;head/meta.html\u0026#34; . }} {{ partial \u0026#34;head/styles.html\u0026#34; . }} {{ partial \u0026#34;head/scripts.html\u0026#34; . }} \u0026lt;!-- 这里插入 MathJax 脚本 --\u0026gt; {{ partial \u0026#34;mathjax-support.html\u0026#34; . }} \u0026lt;/head\u0026gt; ","date":"2025-02-26T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/hugo-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B4%E5%A6%82%E4%BD%95%E5%9C%A8hugo%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7%E5%92%8C%E5%BC%95%E7%94%A8/","title":"Hugo 搭建网站系列教程4：如何在hugo下实现公式自动编号和引用"},{"content":"安装 Ubuntu 的方法 注：下载不同版本要依赖于你想要做的东西，例如最新版的 Ubuntu 已经不支持 ROS1 的使用了，所以如果你想要研究 ROS1 就必须安装对应的版本。\n下载 Ubuntu 的映像文件 首先到 Ubuntu 的官网（）下载你想要安装的版本。\n","date":"2025-02-26T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/%E5%AE%89%E8%A3%85ubuntu%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"安装Ubuntu的全流程及安装会遇到的问题"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://Guilong-gitlab.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://Guilong-gitlab.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Guilong-gitlab.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://Guilong-gitlab.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Design Reviewed | Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/rich-content/","title":"Rich Content"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://Guilong-gitlab.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://Guilong-gitlab.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://Guilong-gitlab.github.io/p/emoji-support/","title":"Emoji Support"}]